# Yata - Complete Implementation Guide

## Instructions for the Implementer

This document contains the complete technical specification and step-by-step implementation plan for the Yata application. It is the **single source of truth** for you to build the project.

**Your workflow MUST be as follows:**

1.  **Follow the Tasks Sequentially:** Implement the project by following the phases and numbered task sections in order.
2.  **Mark Progress:** As you complete each individual checklist item `[ ]`, change it to `[x]` in this file.
3.  **Commit After Each Numbered Section:** After you complete all tasks within a numbered section (e.g., after finishing all of section "2.1. Monorepo Setup"), you must:
    a. Save the changes to this file, reflecting the newly checked-off tasks.
    b. Create a Git commit containing all the code you've written for that section **and** the updated version of this task file.
    c. **IMPORTANT:** Before committing, present the `git commit` message and the changes to me for approval. **WAIT for my approval before proceeding.**

Let's begin.

## 1. Project Overview & Architecture

Yata is a multi-platform application built using a modern TypeScript-first technology stack. The entire project is managed as a **monorepo** using **Bun workspaces**, ensuring code sharing and consistency. The architecture is designed around a central API backend with multiple frontend clients (Web, Mobile, TUI), all syncing data through a robust offline-first mechanism.

### 1.1. Technology Stack

| Component | Technology | Rationale |
| :--- | :--- | :--- |
| **Runtime/Toolkit** | **Bun** | Fast, all-in-one toolkit for package management, bundling, and running TypeScript/JavaScript. |
| **Language** | **TypeScript** | Strict type safety across the entire monorepo. The `no-any` rule will be enforced. |
| **Backend** | **Hono** on Bun | A small, simple, and ultra-fast web framework for the API backend. |
| **Database** | **Supabase** (PostgreSQL) | Provides a robust, scalable SQL database, authentication, and real-time capabilities. |
| **ORM** | **Prisma** | Modern, type-safe database toolkit for TypeScript that simplifies database access and migrations. |
| **Web Frontend** | **React** with **Vite** | Industry-standard for building dynamic UIs, with Vite providing a fast development experience. |
| **Mobile App** | **React Native** | Allows for building native mobile apps for iOS and Android using React. |
| **Terminal App** | **Ink** | A React renderer for command-line interfaces. |
| **Offline Sync** | **WatermelonDB** | A high-performance reactive database framework for building complex, offline-first applications. |
| **Shared UI** | **Tamagui** | A universal UI kit that enables creating shared, performant components for both React Native and web. |
| **Styling** | **Tailwind CSS** | A utility-first CSS framework for rapid, custom UI development. |
| **Animations** | **Framer Motion** | A production-ready motion library for React to achieve fluid animations. |
| **Drag & Drop** | **dnd-kit** | A modern, performant, and accessible drag-and-drop toolkit for React. |
| **State Mgmt** | **Zustand** & **TanStack Query** | Zustand for simple local state. TanStack Query for managing server state. |
| **Testing** | **Vitest**, **RTL**, **Playwright** | A modern, comprehensive testing suite to ensure we meet the 80%+ coverage goal. |
| **CI/CD** | **GitHub Actions** | For automating linting, testing, building, and deployment workflows. |

### 1.2. Data Flow & Sync

1.  **Single Source of Truth**: The Supabase (PostgreSQL) database is the single source of truth.
2.  **API Layer**: The `api` app is the sole intermediary between clients and the database.
3.  **Offline-First Clients**: The `web` and `mobile` apps use **WatermelonDB** to maintain a local copy of data. The UI reads from this local DB, making it instantly responsive and fully functional offline.
4.  **Synchronization**: A custom sync engine communicates with a dedicated `/sync` endpoint on the API to push local changes and pull remote changes.

---

## 2. Phase 1: Project Foundation & Backend API

### 2.1. Monorepo Setup
- [x] Initialize a Git repository in the project root.
- [x] Create a root `package.json` file using `bun init`.
- [x] Modify the root `package.json` to define Bun workspaces:
  ```json
  {
    "name": "yata",
    "workspaces": ["apps/*", "packages/*"]
  }
  ```
- [x] Create the main directories: `mkdir -p apps packages .github/workflows`.
- [x] Create a `.gitignore` file in the root with standard ignores for `node_modules`, `.env`, build artifacts, and IDE folders.

### 2.2. Shared Configurations
- [x] Create `packages/eslint-config-custom/index.js` for a shared ESLint configuration.
- [x] Create `packages/tsconfig-custom/base.json` for a shared TypeScript configuration with strict settings (`"strict": true`, `"noImplicitAny": true`).
- [x] Create a root `tsconfig.base.json` that references the custom one.

### 2.3. Database Setup (Prisma)
- [x] Create the database package directory: `mkdir packages/db`.
- [x] Initialize a `package.json` inside `packages/db` and add Prisma as a dependency.
- [x] Initialize Prisma: `bunx prisma init --datasource-provider postgresql`.
- [x] **Action Item:** Manually create a new project in **Supabase**, navigate to the database settings, and copy the connection string.
- [x] Update `packages/db/.env` with the Supabase connection string.
- [x] Replace the content of `packages/db/prisma/schema.prisma` with the schema below.
- [x] Run the first database migration: `bunx prisma migrate dev --name "initial_schema"`.
- [x] Add a script to `packages/db/package.json` for generating the client: `"db:generate": "prisma generate"`.

**Prisma Schema (`packages/db/prisma/schema.prisma`):**
```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String     @id @default(uuid())
  email     String     @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  tasks     Task[]
  projects  Project[]
  taskTypes TaskType[]
}

model Task {
  id            String    @id @default(uuid())
  title         String
  content       String?   @db.Text
  status        String
  section       String
  order         Float
  urls          String[]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  dueDate       DateTime?
  whenDate      DateTime?
  startedDate   DateTime?
  completedDate DateTime?
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  projectId     String?
  project       Project?  @relation(fields: [projectId], references: [id], onDelete: SetNull)
  typeId        String?
  type          TaskType? @relation(fields: [typeId], references: [id], onDelete: SetNull)
  parentId      String?
  parent        Task?     @relation("TaskHierarchy", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  subtasks      Task[]    @relation("TaskHierarchy")
  blocking      _TaskDependencies[] @relation("blocking")
  blockedBy     _TaskDependencies[] @relation("blockedBy")
}

model _TaskDependencies {
  blockingId  String
  blockedById String
  blocking    Task   @relation("blocking", fields: [blockingId], references: [id], onDelete: Cascade)
  blockedBy   Task   @relation("blockedBy", fields: [blockedById], references: [id], onDelete: Cascade)
  @@id([blockingId, blockedById])
}

model Project {
  id        String   @id @default(uuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tasks     Task[]
  @@unique([userId, name])
}

model TaskType {
  id        String   @id @default(uuid())
  name      String
  icon      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tasks     Task[]
  @@unique([userId, name])
}
```

### 2.4. Backend API (Hono)
- [x] Create and initialize the `apps/api` package.
- [x] Add Hono dependencies: `bun add hono zod @hono/zod-validator`.
- [x] Create `apps/api/src/index.ts` with a basic Hono server.
- [x] Add a `dev` script to `apps/api/package.json`: `"dev": "bun --watch src/index.ts"`.
- [x] Implement the API endpoints as defined below. All endpoints are under the `/api/v1` base path.
- [x] **`/sync` Endpoint:** Implement the `POST /sync` endpoint. This is the most critical part. It must:
    - Accept a request body: `{ "lastPulledAt": "...", "changes": { "tasks": { "created": [...], "updated": [...], "deleted": [...] } } }`
    - Process incoming `changes` by creating, updating, or deleting records in the database using Prisma.
    - Query the database for all records updated since `lastPulledAt`.
    - Respond with server changes: `{ "changes": { "tasks": { "created": [...], "updated": [...] } } }`
- [x] **CRUD Endpoints:** Implement standard CRUD endpoints for `tasks`, `projects`, and `types` (e.g., `GET /tasks`, `POST /tasks`, etc.).
- [x] **Reorder Endpoint:** Implement `POST /tasks/reorder` to batch update task `section` and `order` from a request body like `[{ "id": "...", "section": "Now", "order": 1.5 }]`.

## 3. Phase 2: Core Logic & Web Application

### 3.1. Core Package (`packages/core`)
- [x] Create and initialize the `packages/core` package.
- [x] Add Zod and WatermelonDB dependencies.
- [x] In `packages/core/src/validation.ts`, define Zod schemas that match the Prisma models for client-side validation.
- [x] In `packages/core/src/db/schema.ts`, define the WatermelonDB schema, mirroring the Prisma schema.
- [x] In `packages/core/src/db/models/`, define a WatermelonDB model file for each table (e.g., `Task.js`).

### 3.2. NLP Package (`packages/nlp`)
- [ ] Create and initialize the `packages/nlp` package.
- [ ] Add `chrono-node` dependency.
- [ ] In `packages/nlp/src/index.ts`, create a `parseTask(input: string)` function that uses regex and `chrono-node` to parse a string into a structured task object: `{ title: string, project?: string, type?: string, dueDate?: Date }`.

### 3.3. Web App Setup (`apps/web`)
- [ ] Create the web app using `bun create vite apps/web -- --template react-ts`.
- [ ] Add dependencies: `zustand`, `@tanstack/react-query`, `framer-motion`, `dnd-kit`, `tailwindcss`, and local packages (`@yata/core`, `@yata/nlp`).
- [ ] Initialize and configure Tailwind CSS for Vite.
- [ ] In `main.tsx`, set up the WatermelonDB `LokiJSAdapter` and provide the database instance to the app via a React Context.

### 3.4. Web App UI Implementation
- [ ] Structure the `src` directory with `components`, `pages`, `hooks`, `lib`.
- [ ] Create the `TaskBoard.tsx` page, which will hold the main state and layout.
- [ ] Create the `TaskSection.tsx` component to render a column of tasks.
- [ ] Create the `TaskCard.tsx` component to display a single task.
- [ ] Implement drag-and-drop using `dnd-kit`, wrapping the board in `<DndContext>`.
- [ ] Add `Framer Motion` layout animations to `TaskCard` for fluid movement.
- [ ] Implement the `QuickEntryInput.tsx` component, using the `@yata/nlp` package for real-time parsing.
- [ ] Implement the `TaskDetailView.tsx` as a modal or separate page.

## 4. Phase 3: Testing & Deployment

### 4.1. Testing
- [ ] Add `vitest` to the monorepo root and configure it for all workspaces.
- [ ] Add `React Testing Library` to the web app.
- [ ] Write unit tests for the `nlp` package and `core` validation logic.
- [ ] Write component tests for `TaskCard` and `TaskSection`.
- [ ] Add `Playwright` for E2E testing.
- [ ] Write an E2E test for creating a task and dragging it to a new section.

### 4.2. CI/CD
- [ ] Create `/.github/workflows/ci.yml`.
- [ ] Configure the workflow to trigger on push/PR to `main`.
- [ ] Add jobs for:
    1.  **Lint & Type-Check**: Run ESLint and `tsc --noEmit`.
    2.  **Test**: Run `vitest run`.
    3.  **Build**: Run `bun run build` for `web` and `api`.

### 4.3. Deployment Preparation
- [ ] Create a multi-stage `Dockerfile` in `apps/api` using `oven/bun` for an optimized production image.
- [ ] Ensure the `apps/web` build output is a standard static directory (`dist`).
- [ ] Create `.env.example` files in each app that requires environment variables.

## 5. Phase 4: Final Polish and Documentation

### 5.1. Accessibility (a11y)
- [ ] Ensure all interactive elements are keyboard-navigable with clear focus states.
- [ ] Use semantic HTML and add ARIA attributes where necessary, especially for drag-and-drop.
- [ ] Check for sufficient color contrast.

### 5.2. Performance Optimization
- [ ] Use `React.lazy()` to code-split the `TaskDetailView`.
- [ ] Use `React.memo` on `TaskCard` to prevent unnecessary re-renders during drag operations.

### 5.3. Project Documentation
- [ ] Create a `README.md` file in the project root.
- [ ] The README should include a project description, tech stack list, and clear setup instructions for developers (clone, `bun install`, `bun run dev`).

---

## 6. Phase 5: Universal UI & Component Migration

This phase focuses on creating a shared UI library with Tamagui to allow components to be used across both the Web and Mobile applications, as specified in the tech spec.

### 6.1. UI Package Setup (`packages/ui`)
- [ ] Create and initialize the `packages/ui` package.
- [ ] Add Tamagui, React, and React Native dependencies: `bun add tamagui @tamagui/config react react-dom react-native react-native-web`.
- [ ] Create a basic Tamagui configuration file (`tamagui.config.ts`) in the package root.
- [ ] Set up the package to build for both web and native platforms.

### 6.2. Create Universal Components
- [ ] Create basic, universal components specified in the tech spec:
    - `packages/ui/src/Button.tsx`
    - `packages/ui/src/Input.tsx`
    - `packages/ui/src/Checkbox.tsx`
    - `packages/ui/src/Typography.tsx` (with `Serif` and `SansSerif` variants)
- [ ] Ensure these components are exported from the package's main entry point.

### 6.3. Migrate Web Components to Universal
- [ ] Move the `TaskCard.tsx` component from `apps/web/src/components` to `packages/ui/src/TaskCard.tsx`.
- [ ] Refactor `TaskCard.tsx` using Tamagui components (`YStack`, `XStack`, `Text`, etc.) so it can render on both web and native.
- [ ] Move `TaskSection.tsx` and `TaskBoard.tsx` to `packages/ui` and refactor them to be universal.
- [ ] Update the `apps/web` application to remove its local versions of these components and import them from `@yata/ui` instead.
- [ ] Verify that the web application still looks and functions as it did before the migration.

---

## 7. Phase 6: Mobile Application (React Native)

This phase involves building the native mobile application for iOS and Android using React Native, reusing the core logic and UI components already developed.

### 7.1. Mobile App Setup (`apps/mobile`)
- [ ] Initialize a new React Native project in `apps/mobile`. Use the command: `npx react-native init yata-mobile --directory apps/mobile`.
- [ ] Add local monorepo dependencies: `@yata/core`, `@yata/ui`.
- [ ] Add other required dependencies like WatermelonDB and its native adapters: `@nozbe/watermelondb`, `@nozbe/with-observables`.
- [ ] Link native dependencies: `cd apps/mobile && pod install`.
- [ ] Configure WatermelonDB for React Native, setting up the native SQLite adapter. This involves native code changes in `MainActivity.java` (Android) and `AppDelegate.mm` (iOS).

### 7.2. Mobile UI and Sync Implementation
- [ ] In `apps/mobile/App.tsx`, set up the WatermelonDB provider, similar to the web app.
- [ ] Implement the main application UI using components from `@yata/ui`.
    - Use `TaskBoard.tsx` as the main screen.
- [ ] Implement mobile-specific navigation (e.g., using React Navigation) to handle views like the `TaskDetailView`.
- [ ] Adapt the drag-and-drop functionality for touch interfaces. This may require using `react-native-gesture-handler` in conjunction with `dnd-kit` or a React Native-specific D&D library.
- [ ] Connect the client-side sync logic from `@yata/core` to the API, ensuring offline capabilities work correctly on a mobile device.
- [ ] Test the application on both iOS Simulator and an Android Emulator.

---

## 8. Phase 7: Terminal UI (TUI)

This phase covers the implementation of the command-line interface using Ink, providing a fast, keyboard-driven way to interact with Yata.

### 8.1. TUI App Setup (`apps/tui`)
- [ ] Create and initialize the `apps/tui` package.
- [ ] Add Ink and React dependencies: `bun add ink react`.
- [ ] Create the main entry file `apps/tui/src/cli.tsx`.
- [ ] Add a `bin` field to `apps/tui/package.json` to make the CLI executable (e.g., `"bin": "./src/cli.tsx"`).
- [ ] Add a `dev` script to run the TUI in development: `"dev": "bun --watch src/cli.tsx"`.

### 8.2. TUI Implementation
- [ ] In `cli.tsx`, create the main Ink component for the TUI.
- [ ] Implement a simple API client (using `fetch`) to communicate directly with the backend API. The TUI does not need offline sync.
- [ ] Use TanStack Query (`@tanstack/react-query`) to manage fetching, caching, and refetching data from the API.
- [ ] Design the layout using Ink components (`<Box>`, `<Text>`, `<Newline>`) to display tasks grouped by section ("Now", "Next", etc.).
- [ ] Implement keyboard controls for navigating between tasks and sections using Ink's `useInput` hook.
- [ ] Implement functionality to view task details, add new tasks, and change a task's status/section via keyboard commands.
- [ ] Add support for command-line arguments (e.g., using `yargs` or `mri`) to allow for quick task creation like `yata-tui add "New task for @Project #Type"`.
- [ ] Ensure the TUI is ready to be published to NPM as a package.
