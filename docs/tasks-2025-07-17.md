# Yata - Implementation Tasks

This document provides a detailed, step-by-step guide for building the Yata application from the ground up. Follow each task in the specified order.

YOU MUST: As you complete a task, mark it as completed in this document and save it
YOU MUST: After completing each task section, draft a commit your changes to git history
YOU MUST: Allow me to read through the commit details and approve it before committing

## Phase 1: Project Foundation & Backend API

### 1.1. Monorepo Setup

- [ ] Initialize a Git repository in the project root.
- [ ] Create a root `package.json` file using `bun init`.
- [ ] Modify the root `package.json` to define Bun workspaces:
  ```json
  {
    "name": "yata",
    "workspaces": ["apps/*", "packages/*"]
  }
  ```
- [ ] Create the main directories: `mkdir apps packages .github/workflows`.
- [ ] Create a `.gitignore` file in the root with the following content:

  ```
  # Dependencies
  node_modules
  .DS_Store

  # Bun
  bun.lockb

  # Build artifacts
  dist
  build
  .next
  .tamagui

  # Local environment
  .env
  .env.*
  !.env.example

  # Logs
  *.log

  # IDE
  .idea
  .vscode
  ```

### 1.2. Shared Configurations

- [ ] Create `packages/eslint-config-custom/index.js` for a shared ESLint configuration.
- [ ] Create `packages/tsconfig-custom/base.json` for a shared TypeScript configuration.
  ```json
  {
    "$schema": "https://json.schemastore.org/tsconfig",
    "display": "Default",
    "compilerOptions": {
      "composite": false,
      "declaration": true,
      "declarationMap": true,
      "esModuleInterop": true,
      "forceConsistentCasingInFileNames": true,
      "inlineSources": false,
      "isolatedModules": true,
      "moduleResolution": "node",
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "preserveWatchOutput": true,
      "strict": true,
      "skipLibCheck": true,
      "noImplicitAny": true
    },
    "exclude": ["node_modules"]
  }
  ```
- [ ] Create a root `tsconfig.base.json` that references the custom one.

### 1.3. Database Setup (Prisma)

- [ ] Create the database package directory: `mkdir packages/db`.
- [ ] Initialize a `package.json` inside `packages/db`: `cd packages/db && bun init`.
- [ ] Add Prisma dependencies: `bun add @prisma/client && bun add -d prisma`.
- [ ] Initialize Prisma: `bunx prisma init --datasource-provider postgresql`. This creates `packages/db/prisma/schema.prisma` and `packages/db/.env`.
- [ ] **Action Item:** Manually create a new project in **Supabase**, navigate to the database settings, and copy the connection string.
- [ ] Update `packages/db/.env` with the Supabase connection string: `DATABASE_URL="postgres://..."`.
- [ ] Replace the content of `packages/db/prisma/schema.prisma` with the schema defined in the technical specification.
- [ ] Run the first database migration: `bunx prisma migrate dev --name "initial_schema"`. This will sync the schema with your Supabase database.
- [ ] Add a script to `packages/db/package.json` for generating the client: `"db:generate": "prisma generate"`.

### 1.4. Backend API (Hono)

- [ ] Create the API app directory: `mkdir apps/api`.
- [ ] Initialize a `package.json` inside `apps/api`: `cd apps/api && bun init`.
- [ ] Add Hono dependencies: `bun add hono zod @hono/zod-validator`.
- [ ] Add development dependencies: `bun add -d @types/bun typescript`.
- [ ] Create `apps/api/tsconfig.json` extending the base config.
- [ ] Create `apps/api/src/index.ts` with a basic Hono "hello world" server.
- [ ] Add a `dev` script to `apps/api/package.json`: `"dev": "bun --watch src/index.ts"`.
- [ ] Implement the API endpoints as defined in the tech spec, starting with placeholder logic. Create separate files for each resource's routes (e.g., `src/routes/tasks.ts`).
- [ ] Implement the `/api/v1/sync` endpoint. This is the most critical part.
  - It should accept a `POST` request.
  - It must parse the request body containing `lastPulledAt` and `changes`.
  - It will query the database using Prisma for all records updated since `lastPulledAt`.
  - It will process incoming `changes` by creating, updating, or deleting records in the database.
  - It will return the new set of changes from the server.

## Phase 2: Core Logic & Web Application

### 2.1. Core Package

- [ ] Create the core package directory: `mkdir packages/core`.
- [ ] Initialize a `package.json` inside `packages/core`: `cd packages/core && bun init`.
- [ ] Add Zod for validation: `bun add zod`.
- [ ] Create `packages/core/src/validation.ts` and define Zod schemas that match the Prisma models. This ensures consistent validation across the frontend and backend.
- [ ] Add WatermelonDB: `bun add @nozbe/watermelondb`.
- [ ] Create `packages/core/src/db/schema.ts` and define the WatermelonDB schema. It should mirror the Prisma schema.
- [ ] Create `packages/core/src/db/models/` and define a model file for each table (e.g., `Task.js`). These models will be used by the client-side apps.

### 2.2. NLP Package

- [ ] Create the NLP package directory: `mkdir packages/nlp`.
- [ ] Initialize a `package.json` inside `packages/nlp`: `cd packages/nlp && bun init`.
- [ ] Add date parsing library: `bun add chrono-node`.
- [ ] Create `packages/nlp/src/index.ts` with a `parseTask(input: string)` function.
- [ ] Implement the parsing logic using regex for `#type` and `@project`, and `chrono-node` for dates.

### 2.3. Web App (React + Vite)

- [ ] Create the web app using Vite: `cd apps && bun create vite web -- --template react-ts`.
- [ ] Navigate into the new directory: `cd web`.
- [ ] Install dependencies: `bun install`.
- [ ] Add all required frontend dependencies:
  ```bash
  bun add zustand @tanstack/react-query framer-motion @dnd-kit/core @dnd-kit/sortable
  bun add tailwindcss postcss autoprefixer
  bun add -d @types/react @types/react-dom
  ```
- [ ] Add local packages: `bun add @yata/core @yata/nlp`.
- [ ] Initialize Tailwind CSS: `npx tailwindcss init -p`.
- [ ] Configure `tailwind.config.js` and `index.css` as per Tailwind's documentation for Vite.
- [ ] Set up WatermelonDB in the web app. In `main.tsx`, initialize the database adapter (`LokiJSAdapter`) and connect it to the models from `@yata/core`.
- [ ] Create a `DatabaseProvider` component to make the database instance available throughout the app via React context.

### 2.4. Web App UI Implementation

- [ ] Structure the `src` directory: `mkdir src/components src/pages src/hooks src/lib`.
- [ ] Create the main `TaskBoard` component in `src/pages/TaskBoard.tsx`. This component will hold the state for all tasks.
- [ ] Create the `TaskSection` component (`src/components/TaskSection.tsx`) which receives a list of tasks and renders them.
- [ ] Create the `TaskCard` component (`src/components/TaskCard.tsx`) to display a single task with its metadata.
- [ ] Implement drag-and-drop functionality using `dnd-kit`. Wrap the `TaskBoard` in `<DndContext>` and make `TaskCard`s draggable.
- [ ] Add `Framer Motion` to animate task movements, reordering, and section transitions.
- [ ] Implement the `QuickEntryInput` component, using the `@yata/nlp` package to parse input in real-time and provide feedback.
- [ ] Implement the `TaskDetailView` as a modal or separate page that opens when a task is clicked.
- [ ] Add a markdown renderer (e.g., `react-markdown`) to display task content.

## Phase 3: Cross-Platform Clients

### 3.1. Shared UI Package (Tamagui)

- [ ] Create the UI package directory: `mkdir packages/ui`.
- [ ] Initialize a `package.json` inside `packages/ui`: `cd packages/ui && bun init`.
- [ ] Follow the Tamagui "Getting Started" guide to add dependencies and set up `tamagui.config.ts`.
- [ ] Create a basic, shared `Button.tsx` component in `packages/ui/src/Button.tsx` as a proof of concept.
- [ ] Refactor the web app's `TaskCard` and other components to use Tamagui components from `@yata/ui`. This will prepare them for use in React Native.

### 3.2. Mobile App (React Native)

- [ ] Create the mobile app directory: `mkdir apps/mobile`.
- [ ] Set up a new React Native project inside `apps/mobile` using the React Native CLI or Expo.
- [ ] Add local packages: `bun add @yata/core @yata/nlp @yata/ui`.
- [ ] Set up WatermelonDB for React Native using the native SQLite adapter.
- [ ] Re-create the main `TaskBoard` view using the shared components from `@yata/ui`.
- [ ] Implement mobile-specific touch gestures for task movement as described in the PRD.

### 3.3. Terminal UI (Ink)

- [ ] Create the TUI app directory: `mkdir apps/tui`.
- [ ] Initialize a `package.json` inside `apps/tui`: `cd apps/tui && bun init`.
- [ ] Add Ink dependencies: `bun add ink react`.
- [ ] Create `apps/tui/src/app.tsx`.
- [ ] Build the UI using Ink components, fetching data directly from the API (offline sync is not a primary requirement for the TUI).
- [ ] Implement the keyboard navigation as specified in the PRD (vim-style keys).

## Phase 4: Testing & Deployment

### 4.1. Testing Setup

- [ ] Add Vitest to the root of the monorepo: `bun add -d vitest`.
- [ ] Create a `vitest.config.ts` in the root to configure testing across workspaces.
- [ ] Add React Testing Library to the web app: `bun add -d @testing-library/react @testing-library/jest-dom jsdom`.
- [ ] Write unit tests for the `nlp` package and `core` validation logic.
- [ ] Write component tests for `TaskCard` and `TaskSection`.
- [ ] Add Playwright for E2E testing: `bun add -d @playwright/test`.
- [ ] Write an E2E test for the main user flow: creating a task and dragging it to the "Now" section.

### 4.2. CI/CD

- [ ] Create `/.github/workflows/ci.yml`.
- [ ] Configure the workflow to trigger on pushes to `main` and pull requests.
- [ ] Add jobs for:
  1.  **Lint & Type-Check**: Run ESLint and `tsc --noEmit` on all workspaces.
  2.  **Test**: Run `vitest run` to execute all unit and component tests.
  3.  **Build**: Run `bun run build` for the `web` and `api` apps.
  4.  **(Optional) E2E Tests**: Run `playwright test`.

### 4.3. Deployment Preparation

- [ ] Create a `Dockerfile` in `apps/api` for containerizing the backend service. Use a multi-stage build starting with `oven/bun` to install dependencies and a smaller final image to run the app.
- [ ] Ensure the `apps/web` build output is a standard static directory (`dist`) that can be served by any static host like Vercel.
- [ ] Create `.env.example` files in each app that requires environment variables.

## Phase 5: Advanced Features & Polishing

### 5.1. Implement Core Feature Logic

- [ ] **Task Status Logic:** In the `TaskCard` component, implement the checkbox logic. Clicking it should cycle through the task statuses (`todo` -> `in_progress` -> `done`). The visual state of the checkbox (empty, line, checkmark) must update accordingly.
- [ ] **Section-based Status:** Ensure that when a task is dragged into the "Now" section, its status is automatically updated to `in_progress`. When dragged out, it should revert to `todo`.
- [ ] **Search & Filtering:**
  - Implement a global search bar component.
  - Use a client-side search library like `fuse.js` or leverage WatermelonDB's querying capabilities for instant, offline search across all task fields.
  - Add UI controls for section-specific filtering (by project, type, etc.).
  - Update the WatermelonDB queries to reflect the active filters.
- [ ] **Task Detail View Interactivity:**
  - Enable inline editing for the task title and other text fields.
  - Integrate a native-style date picker for `dueDate` and `whenDate`.
  - Implement the URL field with separate click targets for editing the text and opening the link.
  - Add a markdown editor (like `react-simplemde-editor` or a custom one with `react-markdown`) for the task content area.

### 5.2. Implement Advanced Task Management Features

- [ ] **Subtasks:**
  - In the `TaskDetailView`, add a UI section for creating and listing subtasks.
  - When creating a subtask, it should be linked to the parent task via the `parentId` field.
  - In the main `TaskBoard` view, add a visual indicator (e.g., an icon with a count) to parent tasks that have subtasks.
- [ ] **Task Dependencies:**
  - In the `TaskDetailView`, add a UI for linking tasks as dependencies. This should include a search input to find and select other tasks.
  - Create the `_TaskDependencies` join records in the database when a dependency is set.
  - On the `TaskCard`, display a visual indicator (e.g., a lock icon) if a task is blocked by another incomplete task.
- [ ] **Automatic Task Promotion:**
  - This requires a background process. The best approach is a scheduled job.
  - **Backend:** Create a new, secure API endpoint (e.g., `/api/v1/cron/promote-tasks`). This endpoint will contain the logic to find tasks whose `whenDate` is approaching and move them up the sections (Someday -> Soon -> Next).
  - **Scheduler:** Use a service like **Supabase PG Cron** or a GitHub Actions cron job that calls this endpoint on a daily schedule.
- [ ] **Work-in-Progress (WIP) Limits:**
  - Add a setting in the UI to allow users to configure the WIP limit for the "Now" section.
  - In the `TaskBoard` component, check this limit before allowing a task to be dropped into the "Now" section.
  - If the limit is reached, provide clear visual feedback and prevent the drop (or show a confirmation to override).

## Phase 6: Final Polish and Refinement

### 6.1. Animations and User Experience

- [ ] **Layout Animations:** Use `Framer Motion`'s `LayoutGroup` and `layout` prop on the `TaskCard` components. This will automatically animate tasks as they reorder or move between sections, creating a fluid feel.
- [ ] **Enter/Exit Animations:** Animate tasks appearing and disappearing from lists.
- [ ] **Modal Transitions:** Ensure the `TaskDetailView` modal has a smooth open/close animation.
- [ ] **Haptic Feedback (Mobile):** On the React Native app, use the `react-native-haptic-feedback` library to trigger haptics on gestures like long-press and swipe.
- [ ] **Reduced Motion:** Wrap all animations in a check for the user's OS-level "reduced motion" preference using a hook like `useReducedMotion` from Framer Motion.

### 6.2. Accessibility (a11y)

- [ ] **Keyboard Navigation:** Go through the entire web app using only the keyboard. Ensure all interactive elements are focusable and have a clear focus outline. Implement the specific keyboard shortcuts from the PRD for moving tasks.
- [ ] **Semantic HTML:** Use appropriate HTML tags (`<nav>`, `<main>`, `<button>`, etc.).
- [ ] **ARIA Attributes:** Add ARIA attributes where necessary, especially for the drag-and-drop interface. For example, use `aria-roledescription` for draggable items and provide live announcements for screen readers when a task is moved.
- [ ] **Color Contrast:** Use a browser extension or online tool to check that all text has sufficient color contrast against its background, meeting WCAG AA standards.
- [ ] **Image Alt Text:** Ensure all icons that are not purely decorative have appropriate `aria-label`s.

### 6.3. Performance Optimization

- [ ] **Code Splitting:** Use `React.lazy()` to lazy-load components that are not immediately visible, such as the `TaskDetailView` modal.
- [ ] **Bundle Analysis:** Use a tool like `vite-bundle-visualizer` to inspect the final JavaScript bundle and identify any unnecessarily large dependencies.
- [ ] **Memoization:** Use `React.memo` on components like `TaskCard` to prevent unnecessary re-renders, especially during drag operations.
- [ ] **Database Queries:** Ensure all WatermelonDB queries are efficient and only fetch the data needed for the current view.

### 6.4. Project Documentation

- [ ] **Root README:** Create a `README.md` file in the project root.
- [ ] The README should include:
  - A brief description of the Yata project.
  - A list of the technologies used.
  - Prerequisites for setting up the development environment (e.g., Bun, Git).
  - Step-by-step instructions on how to clone the repo, install dependencies (`bun install`), and run the apps locally (`bun run dev` in `apps/web` and `apps/api`).
  - An explanation of the monorepo structure.

## Phase 7: Final Delivery

### 7.1. Final Review

- [ ] **Manual QA:** Perform a full manual test of all features described in the PRD on both web and mobile.
- [ ] **Cross-Browser Testing:** Test the web application on the latest versions of Chrome, Firefox, and Safari.
- [ ] **Code Cleanup:** Remove all `console.log` statements, commented-out code, and unused files.
- [ ] **Final Merge:** Merge all feature branches into the `main` branch.
- [ ] **Tag Release:** Create a `v1.0.0` git tag to mark the first official release.
